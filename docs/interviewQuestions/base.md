## 计算机原理
## 编译原理
### 1.解释型语言和编译型语言的差异是什么？JavaScript是如何运行的？
**编译型语言**和**解释型语言**这两个都是概念，没有团体或者组织规定这些。

编译型语言是代码在**运行前**编译器将人类可以理解的语言（编程语言）转换成机器可以理解的语言。编译型语言编写的应用在编译后能直接在环境中运行。

解释型语言也是人类可以理解的语言（编程语言），也需要转换成机器可以理解的语言才能执行，但是是在**运行时**转换的，所以执行前需要将**解释器安装在环境中**。

共同点:
  + 都要将源代码转换为二进制代码才能执行。

不同点：
  + 从运行效果上来看。编译型语言要等全部写完后通过编译器去生成一个类似*.exe的二进制文件，然后双击这个文件才可以看到效果。而解释型语言并没生成*.exe文件，而是直接生成效果。
  + 运行的时候是否需要编译器的伴随。编译型语言运行的是最终生成的二进制代码，所以不需要编译器伴随。而解释型语言则一边解释一边运行，需要编译器伴随。
  + 执行的速度对比。编译型语言运行的已经是完全的二进制内容，运行起来十分干净利落，所以速度很快。而解释型语言运行的不一定是完全的二进制内容，因为它是一边解释成二进制一边运行。速度没有前者快，但是CPU的运行速度如果很快，可能看不出来，只是偶尔会看到“有点卡”的效果。
  + 可移植性对比。编译型语言是运行二进制内容，所以一旦CPU指令系统改变，那么之前的二进制文件可能运行不了。可移植性、平台兼容性比价差。而解释型语言是在需要的时候才开始编译、运行。所以它自然具有可移植性，即在任何平台都可以马上运行起来。
  > 要注意的是它的解释工具如：浏览器，本身就是编译型语言解释出来的二进制代码，所以浏览器本身不具备可移植性，是需要针对不同的平台弄出对应的浏览器最终二进制文件的，这里可别混淆。
  + 升级上对比。编译型语言弄出来的二进制文件若要升级，自然要重新下载一个新的二进制文件。所以重新下载、安装、覆盖是最大的特点，体验性就不大好。而解释型的语言只要重新写好源代码即可，用户想要最新的效果，只要刷新一下即可，所以体验性好。

结论：JavaScript代码需要在机器（node或者浏览器）上安装一个工具（JS引擎）才能执行。这是解释型语言需要的。编译型语言产品能够自由地直接运行。

相关文章：
+ [一文了解解释型语言和编译型语言之区别](https://zhuanlan.zhihu.com/p/111763425)
+ [通过v8 0.1.5源码分析js的编译、执行过程](https://zhuanlan.zhihu.com/p/106346315)

### 2.简单描述一下Babel的编译过程？
Babel的编译过程可分为以下是三个过程：
+ 解析(`@babel/parser`，解析器是`babylon`)
  + 该过程将源代码解析成`AST`，并分为两个阶段：词法分析与语法分析。
    + 词法分析:将代码字符串分解为`AST`节点(或者叫`token`令牌流)，如`var a = 1`被分解为`var`、`a`、`=`、`1`四个节点
    + 语法分析:将节点序列转换成一个由元素逐级嵌套的表示程序语法结构的树，这就是AST
+ 转换(`@babel/traverse`)
  + 它提供深度优先遍历`AST`语法树的能力，用于维护操作`AST`的状态，定义了更新、添加和移除节点的操作方法，转换成新的`ATS`。这部分也是`Babel`插件介入工作的部分。
+ 生成(`@babel/generator`)
  + 将经过转换的`AST`通过`@babel/generator`再转换成`js`代码，过程就是深度优先遍历整个 `AST`，然后构建可以表示转换后代码的字符串（就是转换后的es5代码），并生成源码的映射(`source maps)。

相关文章：
+ [Babel的一点理解](https://zhuanlan.zhihu.com/p/367046978)
### 3.JavaScript中的数组和函数在内存中是如何存储的？
**`JavaScript`中的数组存储大致需要分为两种情况：**
+ 快数组：同种类型数据的数组分配连续的内存空间，内部是通过扩容和收缩机制实现动态调整存储空间大小
  + 扩容：扩容后的新容量 = 旧容量的1.5倍 + 16，扩容后会将数组拷贝到新的内存空间中
  + 收缩：容量 >= length的2倍 + 16，则进行收缩容量调整，否则用holes对象填充未被初始化的位置。
+ 慢数组：存在非同种类型数据的数组使用哈希映射分配内存空间
  + 不用开辟大块连续的存储空间，节省了内存。
  + 由于需要维护一个`HashTable`，其效率会比快数组低。

**快数组、慢数组的区别：**
+ 存储方式方面：快数组内存中是连续的，慢数组在内存中是零散分配的。
+ 内存使用方面：由于快数组内存是连续的，可能需要开辟一大块供其使用，其中还可能有很多空洞，是比较费内存的。慢数组不会有空洞的情况，且都是零散的内存，比较节省内存空间。
+ 遍历效率方面：快数组由于是空间连续的，遍历速度很快，而慢数组每次都要寻找`key`的位置，遍历效率会差一些。

**JS函数浏览器中的存储（堆）:**
> 浏览器在读取到函数时，并非直接将函数体中代码执行，而是会将函数以字符串的形式存储在浏览器的内存中，这个过程浏览器会分配一块堆内存用于函数的存储，并记录函数存储的位置(16进制的地址)

**JS代码的执行环境--ECStack：**
+ `ECStack(Execution Context Stack)`
> `ECStack`执行环境栈，它也是浏览器从内存中拿出的一块内存，但是是栈结构内存，作用是执行代码，而非保存代码。
+ `EC(Execution Context)`
> `EC`执行上下文，`EC`不同于`ECStack`它虽然同样是栈内存，但是它的作用是为了在函数执行时，区分全局和函数作用域执行所处的不同作用域（保障每个词法作用域下的代码的独立性）
+ `GO(Global Object)`
> 浏览器会将供JS调用的属性和方法（内置对象）存放在`GO`中，同时浏览器会声明一个名为`window`的属性指向这个对象
+ `AO & VO (Active Object & Variable Object)`
> 代码执行时，会创建变量，`VO`就是用于存储这些变量的空间。`VO`通常用于存放全局变量（全局变量一般情况下是不被释放的），而函数执行或其他情况下形成的私有上下文的变量存储在`AO`中，`AO`是`VO`的一种，区别是`AO`通常指的是进出栈较为频繁的对象

![函数的创建和执行](http://www.mjy-blog.cn/blog-assets/函数运行过程.jpg)

**函数的创建和执行：**
> 函数创建时，会从内存中新建一块堆内存来存储代码块。在函数执行时，会从堆中取出代码字符串，存放在新建的栈中。
+ 创建
  + 开辟堆内存（16进制得到内存地址）
  + 声明当前函数的作用域（函数创建的上下文才是他的作用域，和在那执行的无关）
  + 把函数的代码以字符串的形式存储在堆内存中（函数在不执行的情况下，只是存储在堆内存中的字符串）
  + 将函数堆的地址，放在栈中供变量调用（函数名）
+ 执行
  + 会形成一个全新的执行上下文EC(xx)（目的是供函数体中的代码执行），然后进栈（ECStack执行环境栈）执行
  + 在私有上下文中有一个存放变量的变量对象AO(xx)
  + 代码执行之前需要做的事
    + 初始化作用域链<自己的上下文，函数的作用域>
    + 初始化`this`（箭头函数没有`this`）
    + 初始化`arguments`实参集合（箭头函数没有`arguments`）
    + 形参赋值（形参变量是函数的私有变量，需要存储在AO中）
    + 变量提升（在私有上下文中声明的变量都是私有变量）
![函数运行过程](http://www.mjy-blog.cn/blog-assets/函数的创建和执行.jpg)

相关文章：
+ [js数组内存分配](https://blog.csdn.net/qq_42928070/article/details/113931969)
+ [JavaScript函数的存储机制(堆)和执行原理(栈)](https://zhuanlan.zhihu.com/p/346366911)
### 4.浏览器和Node.js中的事件循环机制有什么区别？
**浏览器内核：**

简单来说浏览器内核是通过取得页面内容、整理信息（应用 CSS）、计算和组合最终输出可视化的图像结果，通常也被称为渲染引擎。

浏览器内核是多线程，在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：
+ `GUI`渲染线程
  + 主要负责页面的渲染，解析`HTML`、`CSS`，构建`DOM`树，布局和绘制等。
  + 当界面需要重绘或者由于某种操作引发回流时，将执行该线程。
  + 该线程与`JS`引擎线程互斥，当执行`JS`引擎线程时，`GUI`渲染会被挂起，当任务队列空闲时，`JS`引擎才会去执行`GUI`渲染。

+ `JS`引擎线程
  + 该线程当然是主要负责处理`JavaScript`脚本，执行代码。
  + 也是主要负责执行准备好待执行的事件，即定时器计数结束，或者异步请求成功并正确返回时，将依次进入任务队列，等待`JS`引擎线程的执行。
  + 当然，该线程与`GUI`渲染线程互斥，当`JS`引擎线程执行`JavaScript`脚本时间过长，将导致页面渲染的阻塞。

+ 定时器触发线程
  + 负责执行异步定时器一类的函数的线程，如：`setTimeout`，`setInterval`。
  + 主线程依次执行代码时，遇到定时器，会将定时器交给该线程处理，当计数完毕后，事件触发线程会将计数完毕后的事件加入到任务队列的尾部，等待`JS`引擎线程执行。

+ 事件触发线程
  + 主要负责将准备好的事件交给`JS`引擎线程执行。
  > 比如`setTimeout`定时器计数结束，`ajax`等异步请求成功并触发回调函数，或者用户触发点击事件时，该线程会将整装待发的事件依次加入到任务队列的队尾，等待`JS`引擎线程的执行。

+ 异步`HTTP`请求线程
  + 负责执行异步请求一类的函数的线程，如：`Promise`、`axios`、`ajax`等。
  + 主线程依次执行代码时，遇到异步请求，会将函数交给该线程处理，当监听到状态码变更，如果有回调函数，事件触发线程会将回调函数加入到任务队列的尾部，等待`JS`引擎线程执行。

**浏览器中的Event Loop：**

**宏队列和微队列：**
  + `macro-task`(宏任务)也叫`tasks`：包括整体代码`script`、`setTimeout`、`setInterval`、`I/O`、`UI Rendering(浏览器独有)`、`requestAnimationFrame(浏览器独有)`、`setImmediate(Node独有)`等
  + `micro-task`(微任务)也叫`jobs`：`Promise.then catch finally`，`process.nextTick(Node独有)`，`MutationObserver`

**浏览器EventLoop的具体流程：**
+ 一开始执行栈（遵循先进后出的原则）空，`micro`队列空，`macro`队列里有且只有一个`script`脚本（整体代码）。
+ 全局上下文（script 标签）被推入执行栈，同步代码执行。在执行的过程中，会判断是同步任务还是异步任务，通过对一些接口的调用，可以产生新的`macro-task`与`micro-task`，它们会分别被推入各自的任务队列里。同步代码执行完了，`script`脚本会被移出`macro`队列，这个过程本质上是队列的`macro-task`的执行和出队的过程。
+ 上一步我们出队的是一个`macro-task`，这一步我们处理的是`micro-task`。处理`micro`队列这一步，会逐个执行队列中的任务并把它出队，直到队列被清空。
  > 需要注意的是：`macro-task`任务是**一个一个**执行的；而`micro-task`任务是**一队一队**执行的。
+ 执行渲染操作，更新界面
+ 检查是否存在`Web worker`任务，如果有，则对其进行处理
+ 上述过程循环往复，直到两个队列都清空

**怎么知道主线程执行栈为空：**

js引擎存在`monitoring process`进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去`Event Queue`那里检查是否有等待被调用的函数。

![浏览器中的Event Loop](http://www.mjy-blog.cn/blog-assets/浏览器中的EventLoop.jpg)

**总结：当某个宏任务执行完后,会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，会读取宏任务队列中排在最前的任务，执行宏任务的过程中，遇到微任务，依次加入微任务队列。栈空后，再次读取微任务队列里的任务，依次类推。**
```js
console.log(1);

setTimeout(() => {
  console.log(2);
  Promise.resolve().then(() => {
    console.log(3)
  });
});

new Promise((resolve, reject) => {
  console.log(4)
  resolve(5)
}).then((data) => {
  console.log(data);
  
  Promise.resolve().then(() => {
    console.log(6)
  }).then(() => {
    console.log(7)
    
    setTimeout(() => {
      console.log(8)
    }, 0);
  });
})

setTimeout(() => {
   console.log(9)
}, 0);
console.log(10)
// 答案：1，4，10，5，6，7，2，3，9，8 你做对了吗？ 如果还不明白的话对照图在走一次。
// Promise.resolve().then(() => {})会立即让回调处于就位状态
```
相关文章：
+ [【图解】浏览器及nodeJS中的EventLoop事件循环机制](https://zhuanlan.zhihu.com/p/389250124)
+ [浏览器与Node的事件循环(Event Loop)有何区别?](https://zhuanlan.zhihu.com/p/54882306)
+ [Node.js VS 浏览器以及事件循环机制](https://juejin.cn/post/6871832597891121166)

## 数据结构
## 算法
## 设计模式
## 编程范式